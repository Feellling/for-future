
###redis为啥这么快？
1. 基于内存的k-v 数据库（结构简单， SDS、双向链表、hash表、压缩数组、跳跃表）
2. 主从分离（哨兵、cluster）
3. 单线程多路复用IO模型（基于文件事件驱动）

###缓存问题
####缓存雪崩
热点数据同时大面积失效 => 某个范围内的随机失效时间
####缓存穿透
查询缓存与数据库都没的数据 => 1、参数校验 2、布隆过滤器（yes）黑名单~
####缓存击穿
某个热点key失效，大面积并发访问导致数据库压力增大 => 从数据库load数据并构建缓存的整个流程，加互斥锁，保证只有一个线程访问到数据库。（分布式锁）


### 常见的缓存读写策略

#### 旁路缓存模式
写：先写DB 再删CACHE
读：先读CACHE, 不存在则读DB并缓存到CACHE

问题：
1. 在写数据的过程中，可以先删除 cache ，后更新 db 么？
不能，会导致数据不一致。
2. 在写数据的过程中，先更新 db，后删除 cache 就没有问题了么？
不一定，但是概率极小。

缺陷：
1：首次请求数据一定不在 cache 的问题   
解决办法：  
可以将热点数据可以提前放入 cache 中。  
2：写操作比较频繁的话导致 cache 中的数据会被频繁被删除，这样会影响缓存命中率 。    
解决办法：  
**数据库和缓存数据强一致场景** ：更新 db 的时候同样更新 cache，不过我们需要加一个锁/分布式锁来保证更新 cache 的时候不存在线程安全问题。  
**可以短暂地允许数据库和缓存数据不一致的场景** ：更新 db 的时候同样更新 cache，但是给缓存加一个比较短的过期时间，这样的话就可以保证即使数据不一致的话影响也比较小

#### 读写穿透

写（Write Through）：  
先查 cache，cache 中不存在，直接更新 db。  
cache 中存在，则先更新 cache，然后 cache 服务自己更新 db（同步更新 cache 和 db）。
读(Read Through)：  
从 cache 中读取数据，读取到就直接返回 。
读取不到的话，先从 db 加载，写入到 cache 后返回响应。

#### 异步缓存写入
读写穿透的异步版本，一般业务上不常用，但是一些中间件在使用。

### 持久化机制
#### RDB 快照模式

save : 同步保存操作，会阻塞 Redis 主线程；  
bgsave : fork 出一个子进程，子进程执行，不会阻塞 Redis 主线程，默认选项。

#### AOF 只追加文件

开启 AOF 持久化后每执行一条会更改 Redis 中的数据的命令，Redis 就会将该命令写入到 AOF 缓冲区 `server.aof_buf` 中，然后再写入到 AOF 文件中（此时还在系统内核缓存区为同步到磁盘），最后再根据持久化方式（fsync策略）的配置来决定何时将系统内核缓存区的数据同步到硬盘中的。


**工作步骤**
- 命令追加（append） ：所有的写命令会追加到 AOF 缓冲区中。
- 文件写入（write） ：将 AOF 缓冲区的数据写入到 AOF 文件中。这一步需要调用write函数（系统调用），write将数据写入到了系统内核缓冲区之后直接返回了（延迟写）。注意！！！此时并没有同步到磁盘。
- 文件同步（fsync） ：AOF 缓冲区根据对应的持久化方式（ fsync 策略）向硬盘做同步操作。这一步需要调用 fsync 函数（系统调用）， fsync 针对单个文件操作，对其进行强制硬盘同步，fsync 将阻塞直到写入磁盘完成后返回，保证了数据持久化。
- 文件重写（rewrite） ：随着 AOF 文件越来越大，需要定期对 AOF 文件进行重写，达到压缩的目的。
- 重启加载（load） ：当 Redis 重启时，可以加载 AOF 文件进行数据恢复。
[步骤](image/aof-work-process.png)

**fsync策略**

appendfsync always：主线程调用 write 执行写操作后，后台线程（ aof_fsync 线程）立即会调用 fsync 函数同步 AOF 文件（刷盘），fsync 完成后线程返回，这样会严重降低 Redis 的性能（write + fsync）。appendfsync everysec ：主线程调用 write 执行写操作后立即返回，由后台线程（ aof_fsync 线程）每秒钟调用 fsync 函数（系统调用）同步一次 AOF 文件（write+fsync，fsync间隔为 1 秒）appendfsync no ：主线程调用 write 执行写操作后立即返回，让操作系统决定何时进行同步，Linux 下一般为 30 秒一次（write但不fsync，fsync 的时机由操作系统决定）。


#### RDB 和 AOF 的混合持久化