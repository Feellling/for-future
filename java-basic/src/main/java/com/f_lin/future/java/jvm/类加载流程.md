##类的加载

### Step1 加载
主要步骤:
1. 通过类的全限定名获取此类的二进制字节流
2. 将字节流所代表的的静态存储结构转换为方法去的运行时数据
3. 在（堆）内存中生成一个代表该类的 `Class` 对象，作为方法区这些数据的入口

加载都是通过 `ClassLoader` 进行的，通过双亲委派模型决定使用哪个加载器来加载，但是数组类则是由虚拟机直接创建的，不是通过加载器加载的。

### Step2 验证
确保class文件的字节流包含的信息符合《Java虚拟机规范》
主要包含：
1. 文件格式验证（class文件格式检查）
2. 元数据验证（字节码语义检查）
3. 字节码验证（程序语义检查）
4. 符号引用验证（类的正确性检查）

这个步骤非必需，生产环境可通过 `-Xverify:none` 关闭

### Step3 准备
- 正式为类变量（静态变量）分配内存以及设置变量初始值（方法区）  
- 类变量所使用内存理论上都在 `方法区` 中进行分配，由于方法区是一个逻辑区域，每个虚拟机实现都不尽相同，比如 hotspot 在jdk7之前使用 `永久代` 来实现方法区，
这个时候，类变量是分配于永久代中的，后边随着jdk7开始将永久代移除，其中字符串常量池、静态变量等数据，都随着Class对象被移动到堆内存中去了。
- 这里的初始值，通常是指的数据类型默认的零值（如 0、0L、null、false 等）。但是针对 `static final` 修饰的常量来说，零值即它被定义的值。

### Step4 解析

将常量池中的符号引用替换为直接引用，也就是得到类或者字段、方法在内存中的指针或者偏移量

### Step5 初始化

执行初始化方法 `<clinit>()` 。<clinit> () 方法是`带锁线程安全`，所以在多线程环境下进行类初始化的话可能会引起多个线程阻塞

#### 几种初始化类的情况（只有使用到类才会进行类的初始化）

1. 当遇到 `new` 、 `getstatic`、`putstatic` 或 `invokestatic` 这 4 条直接码指令时，比如 new 一个类，读取一个静态字段(未被 final 修饰)、或调用一个类的静态方法时。
   - 当 jvm 执行 `new` 指令时会初始化类。即当程序创建一个类的实例对象。
   - 当 jvm 执行 `getstatic` 指令时会初始化类。即程序访问类的静态变量(不是静态常量，常量会被加载到运行时常量池)。
   - 当 jvm 执行 `putstatic` 指令时会初始化类。即程序给类的静态变量赋值。
   - 当 jvm 执行 `invokestatic` 指令时会初始化类。即程序调用类的静态方法。
2. 使用 `java.lang.reflect` 包的方法对类进行反射调用时如 `Class.forname("...")`, `newInstance()` 等等。如果类没初始化，需要触发其初始化。
3. 初始化一个类，如果其父类还未初始化，则先触发该父类的初始化。
4. 当虚拟机启动时，用户需要定义一个要执行的主类 (包含 main 方法的那个类)，虚拟机会先初始化这个类。
5. `MethodHandle` 和 `VarHandle` 可以看作是轻量级的反射调用机制，而要想使用这 2 个调用， 就必须先使用 `findStaticVarHandle` 来初始化要调用的类。
6. 当一个接口中定义了 JDK8 新加入的默认方法（被 `default` 关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。

