### 引用计数法
问题: 无法简单的解决java中的循环引用
### 可达性分析
固定可作为GC Roots的对象
1. 在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的 参数、局部变量、临时变量等。 
2. 在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量。 
3. 在方法区中常量引用的对象，譬如字符串常量池（String Table）里的引用。
4. 在本地方法栈中JNI（即通常所说的Native方法）引用的对象。 
5. Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如 NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器。 
6. 所有被同步锁（synchronized关键字）持有的对象。 
7. 反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。  


根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”地加入(主要指跨代引用的对象)，共同构成完整GC Roots集合


**局部回收**（新生代回收等）时，需要考虑到当前区域的对象有可能会被其他区域的对象所引用。所以需要临时加入其他区域的对象到GC Roots集合中，才能保证可达性分析的正确性。
问题: 怎么判断呢？
在新生代上建立一个全局的数据结构(记忆集), 此结构把老年代划分成若干小块，标识出老年代的哪一块内存会存在跨代引用。
此后当发生Minor GC (Young GC)时，只有包含了跨代引用的小块内存里的对象才会被加入到GC Roots进行扫描。

####引用类型
强（不会回收）
软（内存溢出前，二次GC）
弱（下次GC前）
虚（回收前收到系统通知）

死亡判断：
两次标记   1.可达性分析无引用链标记。2.覆盖finalize()方法,(至多一次执行)->F-Queue,小规模第二次标记

#### 方法区回收

废弃的常量
> 已经没有任何字符串对象引用 常量池中的“java”常量，且虚拟机中也没有其他地方引用这个字面量

不再使用的类型
> 该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。 
> 加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如 OSGi、JSP的重加载等，否则通常是很难达成的。 
> 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方 法。


#### 对象进入老年代的3中情况：

主要有下面三种方式：大对象，长期存活的对象，动态对象年龄判定

1. 大对象直接进入老年代。比如很长的字符串，或者很大的数组等，参数-XX:PretenureSizeThreshold=3145728设置，超过这个参数设置的值就直接进入老年代

2. 长期存活的对象进入老年代。在堆中分配内存的对象，其内存布局的对象头中（Header）包含了 GC 分代年 龄标记信息。如果对象在 eden 区出生，那么它的 GC 分代年龄会初始值为 1，每熬过一次 Minor GC 而不被回收，这个值就会增  加 1 岁。当它的年龄到达一定的数值时，就会晋升到老年代中，可以通过参数-XX:MaxTenuringThreshold设置年龄阀值（默认是 15 岁）

3. 当 Survivor 空间中相同年龄所有对象的大小总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，而不需要达到默认的分代年龄。

