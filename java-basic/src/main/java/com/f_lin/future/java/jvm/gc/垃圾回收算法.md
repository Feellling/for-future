### 分代收集理论

- 弱分代假说（Weak Generational Hypothesis）：绝大多数对象都是朝生夕灭的。  
- 强分代假说（Strong Generational Hypothesis）：熬过越多次垃圾收集过程的对象就越难以消亡。  
- 跨代引用假说（Intergenerational Reference Hypothesis）：跨代引用相对于同代引用来说仅占极少数。  

### 算法

#### 标记-清除
缺点：大量扫描效率低，内存碎片
#### 标记-复制
缺点：存活对象多时，效率低  
优化  
新生代内存分区模型  Eden + Survivor + Survivor (8:1:1)  
新对象->Eden  
标记 Eden + Survivor-From（年龄>?岁后移动到老年代）  --存活-->   Survivor-To  
清理 Eden + Survivor-From 后。 From和To区域互换名称  

分配担保：当Survivor-To空间不足以容纳一次Minor GC之后存活的对象时，就需要依赖其他内存区域（实际上大多就是老年代）进行分配担保
**新生代GC算法**

#### 标记-整理

标记后，让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存，一般用于`老年代`.

缺点：  
这种对象移动操作必须**全程暂停用户应用程序**才能进行

权衡利弊：  
从垃圾收集的停顿时间来看，不移动对象停顿时间会更短，甚至可以不需要停顿，但是从整个程序的`吞吐量`来看，移动对象会更划算。  

吞吐量的实质是`用户程序与收集器的效率总和`。即使不移动对象会使得收集器的效率提升一些，但因`内存分配和访问`相比垃圾收集频率要高得多，这部分的耗时增加，总吞吐量仍然是`下降`的。

关注**吞吐量**的`Parallel Scavenge`收集器是基于标记-整理算法  
关注**延迟**的`CMS`收集器则是基于标记-清除算法  (大多数时间处于)
> 让虚拟机平时多数时间都采用标记-清除算法，暂时容忍内存碎片的存在，直到内存空间的碎片化程度已经大到影响对象分配时，再采用标记-整理算法收集一次，以获得规整的内存空间

### 根节点枚举

在根节点枚举这一步骤必须暂停用户线程!!!（查找引用链的过程已经可以做到与用户线程一起并发）  

根节点枚举始终还是必须在一个能`保障一致性的快照中`才得以进行——这里“一致性”的意思是整个枚举期间执行子系统 看起来就像被冻结在某个时间点上，不会出现分析过程中，根节点集合的对象引用关系还在不断变的情况，若这点不能满足的话，分析结果准确性也就无法保证

#### 虚拟机查找对象引用的方式

OopMap(ordinary object pointer) 普通对象指针(类加载完成后，HotSpot计算对象内什么偏移量上是什么类型的数据，如果是Reference类型则用 OopMap 来存储)
> 一个线程为一个栈，一个栈由多个栈桢组成，一个栈桢对应一个方法，一个方法有多个安全点。GC发生时，程序首先运行到最近的一个安全点停下来，然后更新OopMap，记录栈上哪些位置代表着引用。枚举根节点时，递归遍历每个栈桢的OopMap ，通过栈中记录的被引用的对象内存地址，即可找到这些对象（GC Roots）  
> HotSpot JVM在通过JIT编译时，会在所有方法返回之前以及循环跳转、异常跳转之前放置Safepoint，并且在每个Safepoint都生成一些信息存储哪些地方是引用（OopMap），以便JVM能找到需要的引用

#### 安全点

用户程序执行时 并非在代码指令流的任意位置都能够停顿下来开始垃圾收集，而是强制要求必须执行到达安全点后才能够暂停。

选取规则：
是否具有让程序`长时间执行`的特征（最明显特征就是指令序列的复用，例如方法调用、循环跳转、异常跳转、内存分配-new Object()等）  
线程停顿方案：
抢先式中断 （Preemptive Suspension）//废弃
主动式中断（Voluntary Suspension）
> 当垃圾收集需要中断线程的时候，不直接对线程操作，仅仅简单地在内存中设置一个标志位，各个线程执行过程时会不停地主动去轮询这个标志，一旦发现中断标志为真时就自己在`最近的安全点`上主动中断挂起。
> 轮询标志位和安全点是重合的（到了安全点就轮询一次）  
> 另外在所有创建对象和需要在堆上分配内存的地方也会轮询, 检查是否即将发生垃圾收集，防止没有足够内存分配对象  

轮询方式：内存保护陷阱  
当需要暂停用户线程时，虚拟机会将`标志位的内存页设置为不可读`，那线程执行到`轮询标志位指令`时就会产生一个自陷异常信号，然后在预先注册的`异常处理器`中挂起线程实现等待，这样仅通过一条汇编指令便完成安全点轮询和触发线程中断了。

#### 安全区域

> 指能够确保在某一段代码片段之中，引用关系不会发生变化的区域

**针对**：程序不执行时，典型的场景便是用户线程处于Sleep状态或者Blocked状态，这时候线程无法响应虚拟机的中断请求  
当用户线程执行到安全区域里面的代码时，首先会标识自己已经进入了安全区域，那样当这段时间里虚拟机要发起垃圾收集时就不必去管这些已声明自己在安全区域内的线程了。
当线程要离开安全区域时，它要检查虚拟机是否已经完成了根节点枚举（或者垃圾收集过程中其他需要暂停用户线程的阶段），如果完成了，那线程就当作没事发生过，继续执行；否则它就必须一直等待，直到收到可以离开安全区域的信号为止。

#### 记忆集与卡表

记忆集是一种用于记录从非收集区域指向收集区域的指针集合的抽象数据结构。

根据精度划分：
1. 字长精度：每个记录精确到一个机器字长（就是处理器的寻址位数，如常见的32位或64位，这个 精度决定了机器访问物理内存地址的指针长度），该字包含跨代指针
2. 对象精度：每个记录精确到一个对象，该对象里有字段含有跨代指针
3. 卡精度：每个记录精确到一块内存区域，该区域内有对象含有跨代指针  （卡表）

##### 卡表

一个字节(byte)数组  1btye=8字节   
一个元素，表示一块大小为 2^9 = 512字节 的内存块。假设起始地址为0x0000,则代表每个元素表示 [0x0000~0x01FF]、[0x0200~0x03FF]...的地址块。

###### 卡表状态的维护
写屏障：  
在引用对象赋值时会产生一个环形（Around）通知，供程序执行额外的动作  
问题：高并发下的伪共享
产生原因： 中央处理器的缓存系统中是以缓存行（Cache Line）为单位存储的，当多线程修改互相独立的变量时，如果这些变量恰好共享同一个缓存行，就会彼此影 响（写回、无效化或者同步）而导致性能降低
如果不同线程更新的对象正好处于  `被缓存到同一个缓存行的卡表` 所对应的`内存区域内`，就会导致更新卡表时正好因为是写入同一个缓存行而影响性能

简单的解决方案：  
不采用无条件的写屏障，而是先检查卡表标记，只有当该卡表元素未被标记过时才将其标记为变脏，


#### 并发的可达性分析

##### 对象图的遍历---三色标记法

- 白色：表示对象尚未被垃圾收集器访问过 （不可达）
- 黑色：表示对象已经被垃圾收集器访问过，且这个对象的所有引用都已经扫描过 （安全存活）
- 灰色：表示对象已经被垃圾收集器访问过，但这个对象上至少存在一个引用还没有被扫描过 （过渡色）

问题：  
对象图遍历时，用户线程并发`增加了或者删除了`图中的应用关系  
=> 原本死亡对象被标记为存活  //可容忍。下次GC清理  
=> 应该存活对象被标记为死亡  //程序出错

![三色](image/color.png)

Wilson于1994年在理论上证明了，**当且仅当**以下两个条件**同时满足**时，会产生“对象消失”的问 题，即原本应该是黑色的对象被误标为白色： 
> 赋值器插入了一条或多条从黑色对象到白色对象的新引用     
> 赋值器删除了全部从灰色对象到该白色对象的直接或间接引用    

解决方案：  
- 增量更新(CMS)
当黑色对象插入新的指向白色对象的引用关系时，就将这个新插入的引用记录下来，等并发扫描结束之后，再将这些记录过的引用关系中的黑色对象为根，重新扫描一次
- 原始快照(G1)
当灰色对象要删除指向白色对象的引用关系时，就将这个要删除的引用记录下来，在并发扫描结束之后，再将这些记录过的引用关系中的灰色对象为根，重新扫描一次。