### 分代收集理论

弱分代假说（Weak Generational Hypothesis）：绝大多数对象都是朝生夕灭的。
强分代假说（Strong Generational Hypothesis）：熬过越多次垃圾收集过程的对象就越难以消亡。
跨代引用假说（Intergenerational Reference Hypothesis）：跨代引用相对于同代引用来说仅占极少数。

### 算法

#### 标记-清除
缺点：大量扫描效率低，内存碎片
#### 标记-复制
缺点：存活对象多时，效率低  
优化  
新生代内存分区模型  Eden + Survivor + Survivor (8:1:1)  
新对象->Eden  
标记 Eden + Survivor-From（年龄>?岁后移动到老年代）  --存活-->   Survivor-To  
清理 Eden + Survivor-From 后。 From和To区域互换名称  

分配担保：当Survivor-To空间不足以容纳一次Minor GC之后存活的对象时，就需要依赖其他内存区域（实际上大多就是老年代）进行分配担保
**新生代GC算法**

#### 标记-整理

标记后，让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存，一般用于`老年代`.

缺点：  
这种对象移动操作必须**全程暂停用户应用程序**才能进行

权衡利弊：  
从垃圾收集的停顿时间来看，不移动对象停顿时间会更短，甚至可以不需要停顿，但是从整个程序的`吞吐量`来看，移动对象会更划算。  

吞吐量的实质是`用户程序与收集器的效率总和`。即使不移动对象会使得收集器的效率提升一些，但因`内存分配和访问`相比垃圾收集频率要高得多，这部分的耗时增加，总吞吐量仍然是`下降`的。

关注**吞吐量**的`Parallel Scavenge`收集器是基于标记-整理算法  
关注**延迟**的`CMS`收集器则是基于标记-清除算法  (大多数时间处于)
> 让虚拟机平时多数时间都采用标记-清除算法，暂时容忍内存碎片的存在，直到内存空间的碎片化程度已经大到影响对象分配时，再采用标记-整理算法收集一次，以获得规整的内存空间

### 根节点枚举

在根节点枚举这一步骤必须暂停用户线程!!!（查找引用链的过程已经可以做到与用户线程一起并发）  

根节点枚举始终还 是必须在一个能保障一致性的快照中才得以进行——这里“一致性”的意思是整个枚举期间执行子系统 看起来就像被冻结在某个时间点上，不会出现分析过程中，根节点集合的对象引用关系还在不断变 的情况，若这点不能满足的话，分析结果准确性也就无法保证

#### 虚拟机查找对象引用的方式

1. OopMap (类加载完成后，HotSpot计算对象内什么偏移量上是什么类型的数据，引用则为OopMap)
2. 及时编译时，在`特定的位置`(**安全点**)记录下栈里和寄存器里哪些位置是引用。

#### 安全点

用户程序执行时 并非在代码指令流的任意位置都能够停顿下来开始垃圾收集，而是强制要求必须执行到达安全点后才能够暂停。

选取规则：
是否具有让程序`长时间执行`的特征（最明显特征就是指令序列的复用，例如方法调用、循环跳转、异常跳转等）  
线程停顿方案：
抢先式中断 （Preemptive Suspension）//废弃
主动式中断（Voluntary Suspension）
> 当垃圾收集需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志位，各个线程执行过程时会不停地主动去轮询这个标志，一旦发现中断标志为真时就自己在`最近的安全点`上主动中断挂起。

轮询方式：内存保护陷阱  
当需要暂停用户线程时，虚拟机将特定的`内存页设置为不可读`，那线程执行到改指令时就会产生一个自陷异常信号，然后在预先注册的`异常处理器`中挂起线程实现等待，这样仅通过一条汇编指令便完成安全点轮询和触发线程中断了。

#### 安全区域

> 指能够确保在某一段代码片段之中，引用关系不会发生变化的区域

**针对**：程序不执行时，典型的场景便是用户线程处于Sleep状态或者Blocked状态，这时候线程无法响应虚拟机的中断请求  
当用户线程执行到安全区域里面的代码时，首先会标识自己已经进入了安全区域，那样当这段时间里虚拟机要发起垃圾收集时就不必去管这些已声明自己在安全区域内的线程了。
当线程要离开安全区域时，它要检查虚拟机是否已经完成了根节点枚举（或者垃圾收集过程中其他需要暂停用户线程的阶段），如果完成了，那线程就当作没事发生过，继续执行；否则它就必须一直等待，直到收到可以离开安全区域的信号为止。

#### 记忆集与卡表

记忆集是一种用于记录从非收集区域指向收集区域的指针集合的抽象数据结构。

根据精度划分：
1. 字长精度：每个记录精确到一个机器字长（就是处理器的寻址位数，如常见的32位或64位，这个 精度决定了机器访问物理内存地址的指针长度），该字包含跨代指针
2. 对象精度：每个记录精确到一个对象，该对象里有字段含有跨代指针
3. 卡精度：每个记录精确到一块内存区域，该区域内有对象含有跨代指针  （卡表）

##### 卡表

一个字节(byte)数组  1btye=8字节   
一个元素，表示一块大小为 2^9 = 512字节 的内存块。假设起始地址为0x0000,则代表每个元素表示 [0x0000~0x01FF]、[0x0200~0x03FF]...的地址块。

###### 卡表状态的维护
写屏障：  
在引用对象赋值时会产生一个环形（Around）通知，供程序执行额外的动作  
问题：高并发下的伪共享
产生原因： 中央处理器的缓存系统中是以缓存行（Cache Line）为单位存储的，当多线程修改互相独立的变量时，如果这些变量恰好共享同一个缓存行，就会彼此影 响（写回、无效化或者同步）而导致性能降低
如果不同线程更新的对象正好处于  `被缓存到同一个缓存行的卡表` 所对应的`内存区域内`，就会导致更新卡表时正好因为是写入同一个缓存行而影响性能

简单的解决方案：  
不采用无条件的写屏障，而是先检查卡表标记，只有当该卡表元素未被标记过时才将其标记为变脏，


