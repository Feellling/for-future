### 引用计数法
问题: 无法简单的解决java中的循环引用
### 可达性分析
固定可作为GC Roots的对象
1. 在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的 参数、局部变量、临时变量等。 
2. 在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量。 
3. 在方法区中常量引用的对象，譬如字符串常量池（String Table）里的引用。
4. 在本地方法栈中JNI（即通常所说的Native方法）引用的对象。 
5. Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如 NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器。 
6. 所有被同步锁（synchronized关键字）持有的对象。 
7. 反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。  


根据用户所选用的垃圾收集器以及当前回收的内存区域不 同，还可以有其他对象“临时性”地加入，共同构成完整GC Roots集合
**局部回收**（新生代回收等）时，需要考虑到当前区域的对象有可能会被其他区域的对象所引用。所以需要临时加入其他区域的对象到GC Roots集合中，才能保证可达性分析的正确 性。
问题: 怎么判断呢？
在新生代上建立一个全局的数据结构(记忆集)
结构把老年代划分成若干小块，标识出老年代的哪一块内存会 存在跨代引用。
此后当发生Minor GC (Young GC)时，只有包含了跨代引用的小块内存里的对象才会被加入到GC Roots进行扫描。


强（不会回收）
软（内存溢出前，二次GC）
弱（下次GC前）
虚（回收前收到系统通知）

死亡判断：
两次标记   1.可达性分析无引用链标记。2.覆盖finalize()方法,(至多一次执行)->F-Queue,小规模第二次标记

#### 方法区回收

废弃的常量
> 已经没有任何字符串对象引用 常量池中的“java”常量，且虚拟机中也没有其他地方引用这个字面量

不再使用的类型
> 该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。 
> 加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如 OSGi、JSP的重加载等，否则通常是很难达成的。 
> 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方 法。


