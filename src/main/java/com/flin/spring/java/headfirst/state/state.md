## 状态模式

>状态模式的核心是封装，状态的变更引起了行为的变更，从外部看起来就好像这个对象
 对应的类发生了改变一样。
 

如果需要执行`某个动作 action3（对应state3，需前置执行action2）`的时候，
发现当前状态无法实现此动作时。底层实现需要直接将状态转换到 `state2` 并执行相关的前置处理。
之后转换到`state3`
 
 
 - State——抽象状态角色  
 接口或抽象类，负责对象状态定义，并且封装环境角色以实现状态切换。
 - ConcreteState——具体状态角色  
 每一个具体状态必须完成两个职责：`本状态的行为管理以及趋向状态处理`，通俗地说，
 就是本状态下要做的事情，以及本状态如何过渡到其他状态。
 - Context——环境角色  
 定义客户端需要的接口，并且负责具体状态的切换。
 状态模式相对来说比较复杂，它提供了一种对物质运动的另一个观察视角，通过状态变
 更促使行为的变化，就类似水的状态变更一样，一碗水的初始状态是液态，通过加热转变为
 气态，状态的改变同时也引起体积的扩大，然后就产生了一个新的行为：鸣笛或顶起壶盖，
 瓦特就是这么发明蒸汽机的。
 
### 使用场景

在行为受状态约束的情况下

● 行为随状态改变而改变的场景
这也是状态模式的根本出发点，例如权限设计，人员的状态不同即使执行相同的行为结
果也会不同，在这种情况下需要考虑使用状态模式。

● 条件、分支判断语句的替代者
在程序中大量使用switch语句或者if判断语句会导致程序结构不清晰，逻辑混乱，使用
状态模式可以很好地避免这一问题，它通过扩展子类实现了条件的判断处理。


#### 有空看看？？？
工作流开发，如果不是土制框架，那么就应该有个状态
机管理（即使是土制框架也应该有），如一个Activity（节点）有初始化状态（Initialized
State）、挂起状态（Suspended State）、完成状态（Completed State）等，流程实例也有这么
多状态，那这些状态怎么管理呢？通过状态机（State Machine）来管理，那状态机是个什么
东西呢？就是我们上面提到的Context类的升级变态BOSS！ 